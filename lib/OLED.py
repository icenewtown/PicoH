import time
from lib import font12, font16 

# SSD1306 OLED driver library (128x64) - Pure I2C implementation without external dependencies

# OLED I2C address (default is 0x3C)
OLED_ADDR = 0x3C

# Variables for arrow position tracking in UI
global arrow_x
global arrow_width 
arrow_x = 0
arrow_width = 16

# Arrow pattern buffer
global arrow_buffer, UI
arrow_buffer = bytearray([0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,
0x00,0x01,0x01,0x01,0x01,0x1F,0x1F,0x1F,0x1F,0x1F,0x01,0x01,0x01,0x01,0x00,0x00])  # 8x8 arrow pattern

UI = bytearray(
        
[
0x00,0x00,0x00,0x00,0xF0,0xBC,0x9C,0x0C,0x0C,0xDC,0xF8,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xF0,0xF8,0x0C,0x0C,0x0C,0x0C,0xF8,0xF0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x02,0xFE,0xA8,0xA8,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x24,0xC2,0x7A,0xC2,0xE4,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xE0,0x38,0x24,0x16,0x06,0x0C,0x38,0xE0,0x00,0x00,0x00,0x00,
0x54,0x54,0xFC,0xFF,0x0C,0xEF,0xEC,0xEF,0xEC,0xEF,0xEC,0x0F,0xFC,0xFF,0x54,0x54,
0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x03,0x07,0x07,0x1F,0x7C,0x78,0x00,0x00,0x70,
0x78,0x08,0x38,0x30,0x08,0x78,0x70,0x00,0x38,0x44,0x64,0xB8,0x00,0x64,0x52,0x4C,
0x00,0x00,0x00,0x01,0x03,0x07,0x06,0x06,0x1E,0x7F,0x7C,0xF0,0x40,0x00,0x00,0x00,
0x38,0x3C,0x04,0x18,0x18,0x04,0x3C,0x38,0x00,0x1C,0x22,0x32,0x5C,0x00,0x02,0x02,
0x7A,0x06,0x02,0x00,0x00,0x70,0x8F,0x80,0x8F,0x72,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x02,0x06,0x0E,0x3E,0x23,0x41,0x40,0x41,0x41,0x63,0x7F,0x1C,0x00,0x00,0x00,
0x00,0x08,0x18,0x1F,0x13,0x30,0x70,0x70,0x70,0x30,0x10,0x17,0x0C,0x08,0x00,0x00,
0x15,0x15,0x3F,0xFF,0x30,0xF7,0x37,0xF7,0x37,0xF7,0x37,0xF0,0x3F,0xFF,0x15,0x15,
0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC6,0xC6,0x83,0x93,0xB2,0xF2,0xC6,0x86,0x0C,0x84,0xC0,0xC0,0xC0,0xC0,0x84,0x0C,
0xC6,0xC6,0xC4,0x8C,0x0C,0x00,0xC0,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC9,0x1E,0xE6,0xF3,0x1B,0xC0,0x6D,0xFF,
0x7F,0x99,0xBF,0x2F,0x1A,0x7F,0xFF,0x3F,0x6F,0x1F,0x55,0x7F,0xEF,0x7D,0xF4,0x7E,
0xFF,0x7F,0xDB,0xE6,0xF6,0xC9,0x76,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
])
# Write command to OLED
def write_cmd(i2c, cmd):
    control = 0x00  # Co = 0, D/C# = 0
    i2c.writeto(OLED_ADDR, bytes([control, cmd]))

# Write data to OLED
def write_data(i2c, data):
    control = 0x40  # Co = 0, D/C# = 1
    # data can be bytes or bytearray
    i2c.writeto(OLED_ADDR, bytes([control]) + data)

# Initialize OLED display
def OLED_init(i2c):
    cmds = [
       0xAE,       # Display OFF
        0xD5, 0x80, # Set display clock divide ratio/oscillator freq
        0xA8, 0x3F, # Set multiplex ratio (1 to 64)
        0xD3, 0x00, # Set display offset
        0x40,       # Set start line at 0
        0xA1,       # Segment remap (mirror horizontally)
        0xC8,       # COM output scan direction (mirror vertically)
        0xDA, 0x12, # COM pins hardware config
        0x81, 0x7F, # Set contrast
        0xA4,       # Disable entire display ON (resume RAM content)
        0xA6,       # Normal display (A7 for inverse)
        0xD9, 0xF1, # Pre-charge period
        0xDB, 0x40, # VCOMH deselect level
        0x8D, 0x14, # Charge pump setting (enable)
        0xAF        # Display ON
    ]
    for cmd in cmds:
        write_cmd(i2c, cmd)

# Clear screen (fill with zeros)
def OLED_clear(i2c):
    write_cmd(i2c, 0x20)  # Set Memory Addressing Mode
    write_cmd(i2c, 0x02)  # 0x02 = Page Addressing Mode

    # Then perform page-by-page clearing
    for page in range(8):
        write_cmd(i2c, 0xB0 | page)  # Set page
        write_cmd(i2c, 0x00)         # Set column low = 0
        write_cmd(i2c, 0x10)         # Set column high = 0
        write_data(i2c, b"\x00" * 128)
        # Ensure horizontal addressing mode
    write_cmd(i2c, 0x20)
    write_cmd(i2c, 0x00)  # 0x00 = Horizontal Addressing Mode

    # Set full screen write area
    write_cmd(i2c, 0x21)  # Set Column Address
    write_cmd(i2c, 0x00)  # Column start = 0
    write_cmd(i2c, 0x7F)  # Column end   = 127

    write_cmd(i2c, 0x22)  # Set Page Address
    write_cmd(i2c, 0x00)  # Page start = 0
    write_cmd(i2c, 0x07)  # Page end   = 7

    # Continuously write 1024 0x00 bytes
    write_data(i2c, b"\x00" * 1024)


# Write one page (page:0~7)
def OLED_write_page(i2c, page, buf128):
    if not isinstance(buf128, (bytes, bytearray)) or len(buf128) != 128:
        raise ValueError("buf128 must be 128 bytes of bytes or bytearray")
    write_cmd(i2c, 0xB0 | page)  # Set page address
    write_cmd(i2c, 0x00)         # Set column address low
    write_cmd(i2c, 0x10)         # Set column address high
    write_data(i2c, buf128)

# Write full frame image (1024 bytes)
def OLED_frame(i2c, frame):
    """
    frame: bytes or bytearray, length 1024
    Write and display page by page
    """
    if not isinstance(frame, (bytes, bytearray)) or len(frame) != 1024:
        print("len(frame)", len(frame))
        raise ValueError("frame must be 1024 bytes of bytes or bytearray")
    for page in range(8):
        start = page * 128
        OLED_write_page(i2c, page, frame[start:start+128])


# Write image to specified area
def OLED_write_area(i2c,x_start,x_end,y_start,y_end,buf):
    """
    x_start: Start column address
    x_end: End column address
    y_start: Start page address
    y_end: End page address
    buf: Data buffer with length (x_end-x_start+1)*(y_end-y_start+1)
    """
    if not isinstance(buf, (bytes, bytearray)) or len(buf) != (x_end-x_start+1)*2:
        print("len:,in theory :", len(buf),(x_end-x_start+1)*2)
        raise ValueError("buf must be correctly sized bytes or bytearray")
    
     # Use horizontal writing mode
    write_cmd(i2c,0x00) # Horizontal writing
    cmd=[ 0x21,0x00+x_start,0x00+x_end,0x22,0x00+y_start,0x00+y_end] # Set column and page address range
    for c in cmd:
         write_cmd(i2c,c) # Horizontal address mode

    # Write data
    write_data(i2c, buf)
    # buf: Data buffer with length (x_end-x_start+1)*(y_end-y_start+1)
       
# Display number on OLED
def OLED_num_write(i2c,num):
    if(num<=999.99):
     num_1=num//100
     num_2=num//10-num_1*10
     num_3=num-num_2*10-num_1*100
     num_1=int(num_1)
     num_2=int(num_2)
     num_3=int(num_3)   
     num=(num-num_1*100-num_2*10-num_3)*100
     num_4=int(num//10)
     num_5=int(num-num_4*10)
     
    else:
        print("number is too large to show:",num)
        
    OLED_write_area(i2c,64,75,5,6,bytearray(font12.FONT12[str(num_1)]))
    time.sleep(0.1)
    OLED_write_area(i2c,76,87,5,6,bytearray(font12.FONT12[str(num_2)]))
    time.sleep(0.1)
    OLED_write_area(i2c,88,99,5,6,bytearray(font12.FONT12[str(num_3)]))
    time.sleep(0.1)
    OLED_write_area(i2c,100,101,6,6,bytearray([0X00,0X00,0x0C,0X0C]))
    time.sleep(0.1)
    OLED_write_area(i2c,102,113,5,6,bytearray(font12.FONT12[str(num_4)]))
    time.sleep(0.1) 
    OLED_write_area(i2c,114,125,5,6, bytearray(font12.FONT12[str(num_5)]))

def OLED_word_write(i2c,word):
    width=16
    x_start=0
    word_str=str(word)
  
    for i in range(len(word)):
         time.sleep(0.01)
         OLED_write_area(i2c,x_start,x_start+width-1,4,5,bytearray(font16.FONT16[(word_str[i])]))
         x_start+=width
        
# Move arrow animation
def OLED_arrow_movement(i2c): 
    global arrow_x
    global arrow_width
    global arrow_buffer
    print("",arrow_x)
    if arrow_x != 0:
      # If arrow position is 0, no need to clear previous arrow
      # Clear previous arrow
      OLED_write_area(i2c, arrow_x-arrow_width,arrow_x-1, 2, 3, bytearray([0x00]*16*2))
      if arrow_x==32 or arrow_x==64:
          OLED_write_area(i2c, arrow_x-arrow_width*2,arrow_x-arrow_width-1, 2, 3, bytearray([0x00]*16*2))
    
    if arrow_x >= 127:  # Out of bounds, reset position
        # Clear current image
        x=arrow_x-arrow_width
        OLED_write_area(i2c,x,x+arrow_width-1,2,3,bytearray([0x00]*8*2*2))
        arrow_x = 0
    
    # Draw new arrow
    OLED_write_area(i2c, arrow_x, arrow_x + arrow_width-1,2, 3,arrow_buffer )
    # Update arrow position
    if arrow_x ==0 or arrow_x==32:
        arrow_x += 2*arrow_width
    else:
        arrow_x+=arrow_width
        

